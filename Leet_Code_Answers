#Merge Alternating Words
import numpy

class Solution(object):
    def mergeAlternately(self, word1, word2):
        #CAN'T DO LEN() w/INTS! MUST CONVERT TO STRING (ex = x = 121 --> len(str(x)) gives 3 cuz 121 is 3 has three digits) 
        word1_size = len(word1)
        #DEBUG
        print(word1_size)
        word2_size = len(word2)
         #DEBUG
        print(word2_size)
        result = ""
        i = 0 
        while (i < word1_size or i < word2_size):
            #DEBUG
            print(i)
            if(i < word1_size):
                result+=word1[i]
            if(i < word2_size):
                result+=word2[i]
            i+=1
            
        return "".join(result)

        #word1="abc"
        #word2="xyz"
        
        #print(mergeAlternately(word1, word2))

       # Create loop to iterate index from 0 to max_word_size

       # Create if condition in loop to check index does not exceed work1 size or word2 size

#Array Two Sum 

class Solution(object):
    def twoSum(self, nums, target):
        #print nums  (had to comment these out because it takes too long to compile lists with thousands of elements, they were just here to debug) 
        #print target
        i = 0
        k = 0
        print(len(nums))
        # range (0, 5, 1) will print 0-->4 (the 1 increments by 1) 
        for i in range(0, len(nums), 1):
            x = nums[i]
            # DEBUG
            #print("i:", i)
            #print("x:", x)
            for k in range (i+1, len(nums), 1):
                y = nums[k]
                # DEBUG
                #print("k:", k)
                #print("y:", y)
                if (x+y) == target:
                    print(i,k)
                    output = [i,k]
                    return output

#Repeated Substring Pattern 

class Solution(object):
    def repeatedSubstringPattern(self, s):
        print(s)
        print(self)
        """
        self = string inputted 
        :type s: str
        :rtype: bool

        Here we combine our string input to itself since if there is a repeating substring within it, it 
        will appear in this combination. We have to remove first and last char in string cuz it will just
        always return true. In the given problem, we're looking for substrings that are shorter than
        the entire string (excluding the entire string itself) and that can be repeated to form the
        original string. That's why we start the iteration from 1 (excluding length 0) and end it at n-1 
        (excluding the length of the entire string).
        """

        concat_string = s + s
        concat_string = concat_string[1:]
        concat_string = concat_string[:-1]
        print(concat_string)

        # Here we are checking for our s input within concat_string. If we find s within concat_string,
        # we return true, otherwise return false 
        
        if s in concat_string: 
            return True
        else: 
            return False 


